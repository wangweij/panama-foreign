// Generated by jextract

package com.sun.security.auth.module.windows;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.ValueLayout.*;
public class windows_h  {

    /* package-private */ windows_h() {}
    public static ValueLayout.OfByte C_CHAR = JAVA_BYTE;
    public static ValueLayout.OfShort C_SHORT = JAVA_SHORT;
    public static ValueLayout.OfInt C_INT = JAVA_INT;
    public static ValueLayout.OfInt C_LONG = JAVA_INT;
    public static ValueLayout.OfLong C_LONG_LONG = JAVA_LONG;
    public static ValueLayout.OfFloat C_FLOAT = JAVA_FLOAT;
    public static ValueLayout.OfDouble C_DOUBLE = JAVA_DOUBLE;
    public static ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;
    public static int LANG_NEUTRAL() {
        return (int)0L;
    }
    public static int SUBLANG_DEFAULT() {
        return (int)1L;
    }
    public static int LOAD_LIBRARY_AS_DATAFILE() {
        return (int)2L;
    }
    public static int FORMAT_MESSAGE_ALLOCATE_BUFFER() {
        return (int)256L;
    }
    public static int FORMAT_MESSAGE_IGNORE_INSERTS() {
        return (int)512L;
    }
    public static int FORMAT_MESSAGE_FROM_HMODULE() {
        return (int)2048L;
    }
    public static int FORMAT_MESSAGE_FROM_SYSTEM() {
        return (int)4096L;
    }
    public static ValueLayout.OfInt BOOL = JAVA_INT;
    public static ValueLayout.OfAddress PDWORD = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress LPDWORD = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress LPTSTR = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress HANDLE = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress PHANDLE = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress PSID = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress PSID_IDENTIFIER_AUTHORITY = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress PSID_NAME_USE = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress PSID_AND_ATTRIBUTES = ValueLayout.ADDRESS;
    public static int SecurityImpersonation() {
        return (int)2L;
    }
    public static int TokenUser() {
        return (int)1L;
    }
    public static int TokenGroups() {
        return (int)2L;
    }
    public static int TokenPrimaryGroup() {
        return (int)5L;
    }
    public static ValueLayout.OfAddress PTOKEN_USER = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress PTOKEN_GROUPS = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress PTOKEN_PRIMARY_GROUP = ValueLayout.ADDRESS;
    public static ValueLayout.OfAddress HMODULE = ValueLayout.ADDRESS;
    public static MethodHandle GetStdHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$0.GetStdHandle$MH,"GetStdHandle");
    }
    public static MemoryAddress GetStdHandle ( int nStdHandle) {
        var mh$ = RuntimeHelper.requireNonNull(constants$0.GetStdHandle$MH, "GetStdHandle");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(nStdHandle);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle WriteFile$MH() {
        return RuntimeHelper.requireNonNull(constants$0.WriteFile$MH,"WriteFile");
    }
    public static int WriteFile ( Addressable hFile,  Addressable lpBuffer,  int nNumberOfBytesToWrite,  Addressable lpNumberOfBytesWritten,  Addressable lpOverlapped) {
        var mh$ = RuntimeHelper.requireNonNull(constants$0.WriteFile$MH, "WriteFile");
        try {
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CloseHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$0.CloseHandle$MH,"CloseHandle");
    }
    public static int CloseHandle ( Addressable hObject) {
        var mh$ = RuntimeHelper.requireNonNull(constants$0.CloseHandle$MH, "CloseHandle");
        try {
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetLastError$MH() {
        return RuntimeHelper.requireNonNull(constants$0.GetLastError$MH,"GetLastError");
    }
    public static int GetLastError () {
        var mh$ = RuntimeHelper.requireNonNull(constants$0.GetLastError$MH, "GetLastError");
        try {
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle HeapFree$MH() {
        return RuntimeHelper.requireNonNull(constants$0.HeapFree$MH,"HeapFree");
    }
    public static int HeapFree ( Addressable hHeap,  int dwFlags,  Addressable lpMem) {
        var mh$ = RuntimeHelper.requireNonNull(constants$0.HeapFree$MH, "HeapFree");
        try {
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetProcessHeap$MH() {
        return RuntimeHelper.requireNonNull(constants$0.GetProcessHeap$MH,"GetProcessHeap");
    }
    public static MemoryAddress GetProcessHeap () {
        var mh$ = RuntimeHelper.requireNonNull(constants$0.GetProcessHeap$MH, "GetProcessHeap");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetCurrentProcess$MH() {
        return RuntimeHelper.requireNonNull(constants$1.GetCurrentProcess$MH,"GetCurrentProcess");
    }
    public static MemoryAddress GetCurrentProcess () {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.GetCurrentProcess$MH, "GetCurrentProcess");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetCurrentThread$MH() {
        return RuntimeHelper.requireNonNull(constants$1.GetCurrentThread$MH,"GetCurrentThread");
    }
    public static MemoryAddress GetCurrentThread () {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.GetCurrentThread$MH, "GetCurrentThread");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle OpenProcessToken$MH() {
        return RuntimeHelper.requireNonNull(constants$1.OpenProcessToken$MH,"OpenProcessToken");
    }
    public static int OpenProcessToken ( Addressable ProcessHandle,  int DesiredAccess,  Addressable TokenHandle) {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.OpenProcessToken$MH, "OpenProcessToken");
        try {
            return (int)mh$.invokeExact(ProcessHandle, DesiredAccess, TokenHandle);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle OpenThreadToken$MH() {
        return RuntimeHelper.requireNonNull(constants$1.OpenThreadToken$MH,"OpenThreadToken");
    }
    public static int OpenThreadToken ( Addressable ThreadHandle,  int DesiredAccess,  int OpenAsSelf,  Addressable TokenHandle) {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.OpenThreadToken$MH, "OpenThreadToken");
        try {
            return (int)mh$.invokeExact(ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle FreeLibrary$MH() {
        return RuntimeHelper.requireNonNull(constants$1.FreeLibrary$MH,"FreeLibrary");
    }
    public static int FreeLibrary ( Addressable hLibModule) {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.FreeLibrary$MH, "FreeLibrary");
        try {
            return (int)mh$.invokeExact(hLibModule);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DuplicateToken$MH() {
        return RuntimeHelper.requireNonNull(constants$1.DuplicateToken$MH,"DuplicateToken");
    }
    public static int DuplicateToken ( Addressable ExistingTokenHandle,  int ImpersonationLevel,  Addressable DuplicateTokenHandle) {
        var mh$ = RuntimeHelper.requireNonNull(constants$1.DuplicateToken$MH, "DuplicateToken");
        try {
            return (int)mh$.invokeExact(ExistingTokenHandle, ImpersonationLevel, DuplicateTokenHandle);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetSidIdentifierAuthority$MH() {
        return RuntimeHelper.requireNonNull(constants$2.GetSidIdentifierAuthority$MH,"GetSidIdentifierAuthority");
    }
    public static MemoryAddress GetSidIdentifierAuthority ( Addressable pSid) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.GetSidIdentifierAuthority$MH, "GetSidIdentifierAuthority");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetSidSubAuthority$MH() {
        return RuntimeHelper.requireNonNull(constants$2.GetSidSubAuthority$MH,"GetSidSubAuthority");
    }
    public static MemoryAddress GetSidSubAuthority ( Addressable pSid,  int nSubAuthority) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.GetSidSubAuthority$MH, "GetSidSubAuthority");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(pSid, nSubAuthority);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetSidSubAuthorityCount$MH() {
        return RuntimeHelper.requireNonNull(constants$2.GetSidSubAuthorityCount$MH,"GetSidSubAuthorityCount");
    }
    public static MemoryAddress GetSidSubAuthorityCount ( Addressable pSid) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.GetSidSubAuthorityCount$MH, "GetSidSubAuthorityCount");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetTokenInformation$MH() {
        return RuntimeHelper.requireNonNull(constants$2.GetTokenInformation$MH,"GetTokenInformation");
    }
    public static int GetTokenInformation ( Addressable TokenHandle,  int TokenInformationClass,  Addressable TokenInformation,  int TokenInformationLength,  Addressable ReturnLength) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.GetTokenInformation$MH, "GetTokenInformation");
        try {
            return (int)mh$.invokeExact(TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle IsValidSid$MH() {
        return RuntimeHelper.requireNonNull(constants$2.IsValidSid$MH,"IsValidSid");
    }
    public static int IsValidSid ( Addressable pSid) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.IsValidSid$MH, "IsValidSid");
        try {
            return (int)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle LocalFree$MH() {
        return RuntimeHelper.requireNonNull(constants$2.LocalFree$MH,"LocalFree");
    }
    public static MemoryAddress LocalFree ( Addressable hMem) {
        var mh$ = RuntimeHelper.requireNonNull(constants$2.LocalFree$MH, "LocalFree");
        try {
            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle FormatMessageA$MH() {
        return RuntimeHelper.requireNonNull(constants$3.FormatMessageA$MH,"FormatMessageA");
    }
    public static int FormatMessageA ( int dwFlags,  Addressable lpSource,  int dwMessageId,  int dwLanguageId,  Addressable lpBuffer,  int nSize,  Addressable Arguments) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.FormatMessageA$MH, "FormatMessageA");
        try {
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle LookupAccountSidA$MH() {
        return RuntimeHelper.requireNonNull(constants$3.LookupAccountSidA$MH,"LookupAccountSidA");
    }
    public static int LookupAccountSidA ( Addressable lpSystemName,  Addressable Sid,  Addressable Name,  Addressable cchName,  Addressable ReferencedDomainName,  Addressable cchReferencedDomainName,  Addressable peUse) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.LookupAccountSidA$MH, "LookupAccountSidA");
        try {
            return (int)mh$.invokeExact(lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle LookupAccountNameA$MH() {
        return RuntimeHelper.requireNonNull(constants$3.LookupAccountNameA$MH,"LookupAccountNameA");
    }
    public static int LookupAccountNameA ( Addressable lpSystemName,  Addressable lpAccountName,  Addressable Sid,  Addressable cbSid,  Addressable ReferencedDomainName,  Addressable cchReferencedDomainName,  Addressable peUse) {
        var mh$ = RuntimeHelper.requireNonNull(constants$3.LookupAccountNameA$MH, "LookupAccountNameA");
        try {
            return (int)mh$.invokeExact(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static int TOKEN_DUPLICATE() {
        return (int)2L;
    }
    public static int TOKEN_READ() {
        return (int)131080L;
    }
    public static MemoryAddress INVALID_HANDLE_VALUE() {
        return constants$3.INVALID_HANDLE_VALUE$ADDR;
    }
    public static int STD_ERROR_HANDLE() {
        return (int)4294967284L;
    }
}


